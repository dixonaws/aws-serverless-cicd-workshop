[
{
	"uri": "/",
	"title": "CI/CD for Serverless Applications",
	"tags": [],
	"description": "",
	"content": "CI/CD for Serverless Applications (Java Walkthrough) In this workshop, you will learn how to start a new Serverless application from scratch using the AWS Serverless Application Model (AWS SAM) and how to fully automate builds and deployments by building a continous delivery pipeline using AWS CodeCommit, AWS CodeBuild and AWS CodePipeline. You will also learn how to test a Serverless application locally using the SAM CLI.\nIssues, Comments, Feedback? I’m open source! If you see an issue, want to contribute content, or have overall feedback please open an issue or pull request in our GitHub repository: github.com/aws-samples/aws-serverless-cicd-workshop.\n  Report an issue   Learn more  "
},
{
	"uri": "/buildpipe/pipeline/launch.html",
	"title": "Launch template",
	"tags": [],
	"description": "",
	"content": "Open the AWS CloudFormation console to launch a new stack and upload the downloaded template by choosing the Upload a template file option.\nThe CodeCommitRepoName parameter is pre-populated with sam-app. If you named your CodeCommit repository differently, then update this parameter accordingly.\nThe DeployStackName is pre-populated with sam-app as well. This value refers to the name of the CloudFormation stack for the SAM app that your pipeline will be deploying. You did this on Chapter 3. Click Next.\nOn the next screen, leave everything as is and just click Next.\nFinally, scroll down, tick the checkbok and click Next.\nWait for creation After a couple of minutes, your pipeline should be provisioned.\n"
},
{
	"uri": "/canaries/rollbacks/waitfordeploy.html",
	"title": "Wait for deployment to start",
	"tags": [],
	"description": "",
	"content": "Again, wait for your Pipeline to reach the deployment phase (ExecuteChangeSet). It should turn blue when it begins:\n"
},
{
	"uri": "/buildpipe/gitrepo.html",
	"title": "Create a Git Repository",
	"tags": [],
	"description": "",
	"content": "Any CI/CD pipeline starts with a code repository. In this workshop we use AWS CodeCommit for ease of integration, but you could use other source code integrations, like GitHub for example.\nRun the following command from your terminal to create a new CodeCommit repository:\naws codecommit create-repository --repository-name sam-app You should see the following output. Copy the value of cloneUrlHttp, you will need it later.\n"
},
{
	"uri": "/manualdeploy/bucket.html",
	"title": "Let&#39;s talk about artifacts",
	"tags": [],
	"description": "",
	"content": "Artifacts refer to the output of your build process in the context of CI/CD. Artifacts are typically in the form of a zip/tar file, a jar or a binary. You then take these artifacts and deploy them onto your different environments (i.e. Dev, Test, Prod). For Serverless projects, artifacts must be uploaded to an S3 bucket for the Lambda service to pick them up. The SAM CLI takes care of managing this process of uploading artifacts to S3 and referencing them at deployment time.\nThe Zip file The first artifact that gets generated in a Serverless project is your codebase, which gets compressed in a zip file and uploaded to an S3 bucket automatically by the SAM CLI during the package phase (more on this later).\nThe Packaged Template The second artifact that SAM CLI generates during the package phase is the packaged template. Which is basically a copy of your project\u0026rsquo;s template.yaml, except that it references the location of the zip file (first artifact) in the S3 bucket. The following image shows an example of a packaged template.\nNotice how the CodeUri references the zip file on an S3 bucket, rather than on a local directory. This is how AWS Lambda is able to pull your code at deployment time.\n"
},
{
	"uri": "/local/dependencies.html",
	"title": "Install dependencies",
	"tags": [],
	"description": "",
	"content": "Before we run the application locally, it\u0026rsquo;s a common practice to install third-party libraries or dependencies that your application might be using. These dependencies are defined in a file that varies depending on the runtime, for example package.json for NodeJS projects or requirements.txt for Python ones.\nIn the terminal, go into the sam-app/hello-world folder.\ncd sam-app/hello-world And install the dependencies:\nnpm install Example:\n"
},
{
	"uri": "/sam/init.html",
	"title": "Initialize project",
	"tags": [],
	"description": "",
	"content": "AWS SAM provides you with a command line tool, the AWS SAM CLI, that makes it easy for you to create and manage serverless applications. It particularly makes easy the scaffolding of a new project, as it creates the initial skeleton of a hello world application, so you can use it as a baseline and continue building your project from there.\nRun the following command to scaffold a new project:\nsam init It will prompt for project configuration parameters:\nType 1 to select AWS Quick Start Templates Choose nodejs12.x for runtime Leave default sam-app for project name Type Y to accept download from GitHub This command supports cookiecutter templates, so you could write your own custom scaffolding templates and specify them using the location flag, For example: sam init \u0026ndash;location git+ssh://git@github.com/aws-samples/cookiecutter-aws-sam-python.git.\n Project should now be initialized You should see a new folder sam-app created with a basic Hello World scaffolding. If you are interested in learning more about initializing SAM projects, you can find the full reference for the sam init command in the SAM CLI reference.\n"
},
{
	"uri": "/setup/cloud9.html",
	"title": "Create a Cloud9 Workspace",
	"tags": [],
	"description": "",
	"content": " Ad blockers, javascript disablers, and tracking blockers should be disabled for the cloud9 domain, or connecting to the workspace might be impacted. Cloud9 requires third-party-cookies. You can whitelist the specific domains.\n Navigate to the Cloud9 console: Navigate to the Cloud9 console: https://console.aws.amazon.com/cloud9\nCreate a workspace Once you navigate to the Cloud9 console, click on the create environment button: Chose a name for your environment. Leave the default configuration, we don\u0026rsquo;t need a heavy server for this workshop. Once you confirm creation, after a couple of minutes, your environment should look like the following image: (Optional) If you prefer a dark theme, chose the theme in the top menu: View \u0026gt; Themes \u0026gt; Cloud9 \u0026gt; Cloud 9 Night. "
},
{
	"uri": "/setup.html",
	"title": "Setup",
	"tags": [],
	"description": "",
	"content": "Setup AWS Account In order to complete this workshop, you’ll need access to an AWS account. Your access needs to have sufficient permissions to create resources in IAM, CloudFormation, API Gateway, CodeCommit, CodePipeline, CodeBuild, CodeDeploy and S3. If you currently don\u0026rsquo;t have an AWS account, you can create one here: https://aws.amazon.com/premiumsupport/knowledge-center/create-and-activate-aws-account.\nSetup using AWS Cloud9 (Recommended) AWS Cloud9 is a cloud-based integrated development environment (IDE) that lets you write, run, and debug code from any machine with just a browser. We recommend using it to run this workshop because it already comes with the necessary set of tools pre-installed, but the workshop is not dependent on it, so you are free to run it from your local computer as well.\nIf you want to use Cloud9, follow these instructions: Create a Cloud9 Workspace.\nSetup using my own computer, not using Cloud9 If you prefer to run the workshop from your local computer without using Cloud9, make sure you install the following tools which are available for Linux, MacOS and Windows.\n Docker Desktop - Required to simulate the Lambda runtime locally. SAM CLI v0.31.0+ - To run functions locally and package/deploy SAM apps. AWS CLI - To create resources in your AWS account. Git Client - To interact with the CodeCommit repository by pushing code changes. NodeJS and npm - The sample app you will create is NodeJs-based.  Once you have installed all requirements, you can start the workshop here: Start workshop.\n"
},
{
	"uri": "/sam/architecture.html",
	"title": "Project Architecture",
	"tags": [],
	"description": "",
	"content": "The Hello World SAM project you just created will create the following architecture when deployed. It has a single Lambda function, an API Gateway that exposes a /hello resource and invokes the Lambda function when called with an HTTP GET request. The Lambda function assumes an IAM role that can have permissions to interact with other AWS resources, like a database for example.\nIn the next page, we will explore the structure and code of a SAM project. "
},
{
	"uri": "/canaries/rollbacks/faketraffic.html",
	"title": "Invoke the canary",
	"tags": [],
	"description": "",
	"content": "While the deployment is running, you need to generate traffic to the new Lambda function to make it fail and trigger the CloudWatch Alarm. In a real production environment, your users will likely generate organic traffic to the canary function, so you may not need to do this.\nIn your terminal, run the following command to invoke the Lambda function:\naws lambda invoke --function-name \\ $(aws lambda list-functions | jq -r .Functions[0].FunctionName):live \\ --payload '{}' \\ response.json Example:\nThere will be a new file response.json created. It contains the response of the lambda invocation. If you open it, you may see the the response of the old Lambda version, or you may see the new one that causes an error.\nRemember: During deployment, only 10% of the traffic will be routed to the new version. So, keep on invoking your lambda many times. 1 out of 10 invocations should trigger the new broken lambda, which is what you want to cause a rollback.\nHere is a command that invokes your function 15 times in a loop. Feel free to run it in your terminal.\ncounter=1 while [ $counter -le 15 ] do aws lambda invoke --function-name \\ $(aws lambda list-functions | jq -r .Functions[0].FunctionName):live \\ --payload '{}' \\ response.json sleep 1 ((counter++)) done "
},
{
	"uri": "/canaries/intro.html",
	"title": "How does it work",
	"tags": [],
	"description": "",
	"content": "Before we jump into implementing Canary Deployments, lets first understand how this works:\nThe concepts of blue/green and canary deployments have been around for a while and have been well-established as best-practices for reducing the risk of software deployments. In traditional applications, you slowly and incrementally update the servers in your fleet while simultaneously verifying application health. However, there is somewhat of an impedance mismatch when mapping these concepts to a serverless world. You can’t incrementally deploy your software across a fleet of servers when there are no servers!\nThe answer is that there are a couple of services and features involved in making this possible. Let us explain:\nLambda versions and aliases AWS Lambda allows you to publish multiple versions of the same function. Each version has its own code and associated dependencies, as well as its own function settings (like memory allocation, timeout and environment variables). You can then refer to a given version by using a Lambda Alias. An alias is nothing but a name that can be pointed to a given version of a Lambda function.\nTraffic shifting with Lambda aliases With the introduction of alias traffic shifting, it is now possible to trivially implement canary deployments of Lambda functions. By updating additional version weights on an alias, invocation traffic is routed to the new function versions based on the weight specified. Detailed CloudWatch metrics for the alias and version can be analyzed during the deployment, or other health checks performed, to ensure that the new version is healthy before proceeding.\nTraffic shifting with SAM and CodeDeploy AWS CodeDeploy provides an intuitive turn-key implementation of this functionality integrated directly into AWS SAM. Traffic-shifted deployments can be declared in a SAM template, and CodeDeploy manages the function rollout as part of the CloudFormation stack update. CloudWatch alarms can also be configured to trigger a stack rollback if something goes wrong.\n"
},
{
	"uri": "/setup/bootstrap.html",
	"title": "Upgrade SAM CLI",
	"tags": [],
	"description": "",
	"content": "One of the tools this workshop relies on, is the AWS SAM Command Line Interface. However, we need a newer version than what Cloud9 has pre-installed. The version we are targetting is SAM CLI, version 0.31.1 or greater.\nBootstrap Script We have put together a bootstrap script that will make the upgrade easier for you. Download it by running the following command from your Cloud9 terminal.\nwget https://serverless-cicd-pipeline-artifacts-cn2m0gigrb70.s3.amazonaws.com/bootstrap.sh Then give it permissions to execute:\nchmod +x bootstrap.sh And run it:\n./bootstrap.sh THIS MAY TAKE A FEW MINUTES TO COMPLETE.\nExample output: Verify the new version Run the following command:\nsam --version You should see SAM CLI, version 0.31.1 or greater.\n"
},
{
	"uri": "/buildpipe/credhelper.html",
	"title": "Configure credentials",
	"tags": [],
	"description": "",
	"content": "One of the cool things about CodeCommit is the support for IAM authentication. And if you are running this workshop from a Cloud9 workspace, you can leverage the fact that your terminal is already pre-authenticated with valid AWS credentials.\nRun the following commands from your terminal:\ngit config --global credential.helper '!aws codecommit credential-helper $@' git config --global credential.UseHttpPath true Now configure the git client with username and email, so your commits have an author defined.\ngit config --global user.name \u0026quot;Replace with your name\u0026quot; git config --global user.email \u0026quot;replace_with_your_email@example.com\u0026quot; Example:\n"
},
{
	"uri": "/manualdeploy/build.html",
	"title": "Build the app",
	"tags": [],
	"description": "",
	"content": "To build a SAM project, we are going to use the sam build command. This command iterates through the functions in your application, looking for the manifest file (such as requirements.txt or package.json) that contains the dependencies, and automatically creates deployment artifacts.\nFrom the root of the sam-app folder, run the following command in the terminal:\ncd ~/environment/sam-app sam build Build completed When the build finishes successfully, you should see a new directory created in the root of the project named .aws-sam. It is a hidden folder, so if you want to see it in the IDE, make sure you enable Show hidden files in Cloud9 to see it. Explore the build folder Take a moment to explore the content of the build folder. Notice that the unit tests are automatically excluded from it. This is because they are specified in the sam-app/hello-world/.npmignore file. "
},
{
	"uri": "/local/run.html",
	"title": "Run using SAM CLI",
	"tags": [],
	"description": "",
	"content": "There are 2 ways of running a Serverless app locally: 1) By invoking an individual Lambda function or 2) By running a local HTTP server that simulates API Gateway. For this workshop, we will focus on number 2, but you can learn about invoking individual functions in the SAM Local Invoke reference.\nIn the terminal, run the following command from the root directory of the sam-app folder:\ncd ~/environment/sam-app sam local start-api --port 8080 In a Cloud9 workspace, you must use port 8080, 8081 or 8082 to be able to open the URL in the local browser for preview.\n Test your endpoint Once your local server is running, we can send HTTP requests to test it. Chose one of the following options:\nOption A) Using CURL Without killing the running process, open a new terminal.\nTest your endpoint by running a CURL command that triggers an HTTP GET request.\ncurl http://localhost:8080/hello Option B) Using a browser window In Cloud9, go to the top menu and chose Tools \u0026gt; Preview \u0026gt; Preview Running Application. A browser tab will open, append /hello to the end of the URL. This will invoke your Lambda function locally.\nNote how SAM is pulling the Docker container image lambci/lambda:nodejs10.x automatically. This is how SAM is able to simulate the Lambda runtime locally and run your function within it. The first invocation might take a few seconds due to the docker pull command, but subsequent invocations should be much faster.\n"
},
{
	"uri": "/sam/template.html",
	"title": "Explore the SAM template",
	"tags": [],
	"description": "",
	"content": "Let\u0026rsquo;s take a moment to understand the structure of a SAM application by exploring the SAM template which represents the architecture of your Serverless application. Go ahead and open the sam-app/template.yaml file.\nIt should have a structure like the following.\nYou may notice that the syntax looks exactly like AWS CloudFormation, this is because SAM templates are an extension of CloudFormation templates. That is, any resource that you can declare in CloudFormation, you can also declare in a SAM template. Let\u0026rsquo;s take a closer look at the components of the template.\nTransform Notice the transform line of the template, it tells CloudFormation that this template adheres to the open source AWS Serverless Application Model specification:\nGlobals This section defines properties common to all your Serverless functions and APIs. In this case, it\u0026rsquo;s specifying that all functions in this project will have a default timeout of 3 seconds.\nHello World Function The following section creates a Lambda function with an IAM execution role. It also specifies that the code for this Lambda function is located under a folder named hello-world, and that its entrypoint is a function named lambdaHandler within a file named app.js.\nNotice that the IAM role is not explicitly specified, this is because SAM will create a new one by default. You can override this behavior and pass your own role by specifying the Role parameter. For a complete list of the parameters you can specify for a Lambda function check the SAM reference.\nEvent Triggers This section is part of the function definition and it specifies the different events that will trigger the Lambda function. In this case, we are specifying the event to be an API Gateway with an endpoint on /hello that will listen on HTTP method GET.\nOutputs The Outputs section is optional and it declares output values that you can import into other CloudFormation stacks (to create cross-stack references), or simply to view them on the CloudFormation console. In this case we are making the API Gateway endpoint URL, the Lambda function ARN and the IAM Role ARN available as Outputs to make them easier to find.\n"
},
{
	"uri": "/sam.html",
	"title": "Create a new SAM app",
	"tags": [],
	"description": "",
	"content": "Create a new SAM app The AWS Serverless Application Model (AWS SAM) is an open-source framework that developers use to build production-grade serverless applications on AWS.\nA serverless application is a combination of Lambda functions, event sources, and other resources that work together to perform tasks. But a serverless application is more than just a Lambda function—it can include additional resources such as APIs, databases, and event source mappings.\nIn this chapter, you will learn how to quickly scaffold a SAM application and understand how it is structured.\n"
},
{
	"uri": "/canaries/rollbacks/codedeploy.html",
	"title": "Watch CodeDeploy rollback",
	"tags": [],
	"description": "",
	"content": "Navigate to the AWS CodeDeploy Console and go into the deployment In-Progress to view its details.\nAfter a few minutes, CodeDeploy will detect that the CanaryErrorsAlarm has triggered and it will start rolling back the deployment. The screen will look something like this:\n"
},
{
	"uri": "/canaries/sam.html",
	"title": "Update SAM template",
	"tags": [],
	"description": "",
	"content": "Open the SAM template (sam-app/template.yaml) in your project and add the following lines to the HelloWorldFunction properties section.\nAutoPublishAlias: live DeploymentPreference: Type: Canary10Percent5Minutes It should look like this:\nPLEASE CHECK THE CORRECT INDENTATION, IT IS VERY IMPORTANT IN YAML FORMAT.\nDeployment Preference Types For this workshop, we are using the Canary10Percent5Minutes strategy, which means that traffic is shifted in two increments. In the first increment, only 10% of the traffic is shifted to the new Lambda version, and after 5 minutes, the remaining 90% is shifted. There are other deployment strategies you can choose in CodeDeploy:\n Canary10Percent30Minutes Canary10Percent5Minutes Canary10Percent10Minutes Canary10Percent15Minutes Linear10PercentEvery10Minutes Linear10PercentEvery1Minute Linear10PercentEvery2Minutes Linear10PercentEvery3Minutes AllAtOnce  The Linear strategy means that traffic is shifted in equal increments with an equal number of time interval between each increment.\nValidate the SAM template Run the following command on your terminal:\ncd ~/environment/sam-app sam validate If the template is correct, you will see template.yaml is a valid SAM Template. If you see an error, then you likely have an indentation issue on the YAML file. Double check and make sure it matches the screenshot shown above.\nPush the changes In the terminal, run the following commands from the root directory of your sam-app project.\ngit add . git commit -m \u0026quot;Canary deployments with SAM\u0026quot; git push "
},
{
	"uri": "/buildpipe/gitpush.html",
	"title": "Push the code",
	"tags": [],
	"description": "",
	"content": "Ignore the build artifacts Copy and paste the following lines at the end of the sam-app/.gitgnore file. There is no need to track the .aws-sam directory or the packaged.yaml under version control as they are re-generated on every build.\n.aws-sam/ packaged.yaml In Cloud9, remember to enable hidden files:\nOpen the .gitignore file and paste the two lines described above.\nFrom the root directory of your sam-app project, run the following commands:\ncd ~/environment/sam-app git init git add . git commit -m \u0026quot;Initial commit\u0026quot; Example: Push the code Add your CodeCommit repository URL as a remote on your local git project. This is the cloneUrlHttp value that you got back after creating the repository in Step 1 of this chapter.\nIf you can\u0026rsquo;t find the CodeCommit repository URL, you can find it by running this command: aws codecommit get-repository --repository-name sam-app.\n git remote add origin REPLACE_WITH_HTTP_CLONE_URL  If you typed the origin url incorrectly, you can remove it by running: git remote rm origin.\n Now, push the code:\ngit push -u origin master Example:\nVerify in CodeCommit Navigate to the AWS CodeCommit console, find your sam-app repository and click on it to view its contents. Make sure your code is there. You should see a screen like the following:\n"
},
{
	"uri": "/local/change.html",
	"title": "Make a code change",
	"tags": [],
	"description": "",
	"content": "While the app is still running, open the file sam-app/hello-world/app.js and make a simple code change. For example, change the response message to return hello my friend instead of hello world. Your Lambda handler should look like this after the change:\nNote: Make sure you save the file after changing it.\nYou don\u0026rsquo;t have to restart the sam local process, just refresh the browser tab or re-trigger the CURL command to see the changes reflected in your endpoint. You only need to restart sam local if you change the template.yaml.\n "
},
{
	"uri": "/local.html",
	"title": "Run project locally",
	"tags": [],
	"description": "",
	"content": "Run project locally Now that you have a SAM application. You will learn how to run it and test it locally using the AWS SAM CLI. This is important because its part of the day to day development workflow. It helps you verify if the application is behaving as expected, debug what\u0026rsquo;s wrong, and fix any issues before pushing your changes to a central repository.\n"
},
{
	"uri": "/sam/code.html",
	"title": "Explore the Lambda code",
	"tags": [],
	"description": "",
	"content": " If you consider yourself an expert using Lambda functions, you can probably skip this page.\n Let\u0026rsquo;s take a look at the code of the Hello World Lambda function. Open the file app.js under the hello-world folder. Note that your function may have additional commented out code, those lines have been removed from the following example for clarity:\nThe Lambda handler The handler is the method in your Lambda function that processes events. When you invoke a function, the runtime runs the handler method. When the handler exits or returns a response, it becomes available to handle another event. In this case, the lambda handler is the lambdaHandler function, as specified in the SAM template.yaml.\nBecause the Lambda handler is executed on every invocation, a best practice is to place code that can be reused across invocations outside of the handler scope. A common example is to initialize database connections outside of the handler.\n Event object The first argument passed to the handler function is the event object, which contains information from the invoker. In this case, the invoker is API Gateway, which passes the HTTP request information as a JSON-formatted string, and the Lambda runtime converts it to an object. You can find examples of event payloads here: https://docs.aws.amazon.com/lambda/latest/dg/lambda-services.html\nContext object The second argument is the context object, which contains information about the invocation, function, and execution environment. You can get information like the CloudWatch log stream name or the remaining execution time for the function.\nHandler Response API Gateway expects the handler to return a response object that contains statusCode and body, but it can also contain optional headers.\n"
},
{
	"uri": "/buildpipe/pipeline.html",
	"title": "Creating the pipeline",
	"tags": [],
	"description": "",
	"content": "The best way to automate the creation of CI/CD pipelines is by launching them programmatically. This is specially useful in a microservices environment, where you create a pipeline per microservice, which potentially means dozens of pipelines, if not more. Having an automated way to launch pipelines enables developers to create as many as they need without having to build them manually from the console every single time.\nCloudFormation is just one of the many ways you can go about automating Pipeline creation. But there are a few other mechanisms we see customers use as pipeline vending machines. The following list describes some of the most common ones:\n AWS CloudFormation AWS CDK Terraform AWS Serverless App Repository  For this workshop, we are going to use CloudFormation as the vending mechanism. And we have already built a template that will help you get started. From your terminal, download the CloudFormation template:\nwget https://cicd.serverlessworkshops.io/assets/pipeline.yaml Understanding the template (Optional) Let\u0026rsquo;s take a moment to understand the key components of the CloudFormation template.\nThe Artifacts Bucket This is the artifact store for your pipeline. CodePipeline will use this bucket to pass artifacts to the downstream jobs. This is also where SAM will upload the artifacts during the build process. The Source Stage The source stage is the first step of any pipeline and it points to your source code. It determines when to trigger the pipeline based on new changes (i.e. git push). This pipeline uses AWS CodeCommit as the source provider, but CodePipeline also supports S3, GitHub and Amazon ECR as source providers.\nThe Build Stage The build phase uses AWS CodeBuild as the build provider. But CodePipeline supports other providers like Jenkins, TeamCity or CloudBees. CodeBuild is a great option because you only pay for the time when your build is running, which makes it very cost effective.\nA CodeBuild project has information about the build environment. A build environment represents a combination of operating system (Linux or Windows), compute size (Small, Medium, Large) and a Docker image where the build runs. You can bring your own Docker image or use the managed images provided by the service. In this case, we are using the managed image for Amazon Linux 2: aws/codebuild/amazonlinux2-x86_64-standard:2.0.\nThe Deployment Stage This pipeline uses CloudFormation ChangeSets to deploy the SAM application. This is why the deployment stage is composed of 2 steps, the CreateChangeSet and the ExecuteChangeSet. The main thing to highlight here is the TemplatePath, notice how our deployment artifact is the packaged.yaml produced by the SAM build.\nThe Pipeline Definition The pipeline definition is very straightforward. You specify the bucket for artifacts and a list of Stages, which in this case we have 3: 1. Source -\u0026gt; 2. Build -\u0026gt; 3. Deploy to Dev. The configuration for each stage is ommited in the following image because it has already been shown in the screenshots above.\nThe IAM Roles In case you haven\u0026rsquo;t noticed. This pipeline involves 3 different IAM Roles. It\u0026rsquo;s important to be aware of them in case you need to troubleshoot a permissions error, depending on what stage of the pipeline you got it, you know what role to modify.\n CodeBuild Role: Assumed by CodeBuild to write SAM artifacts to S3. Deployment Role: Assumed by CloudFormation to create resources at the deploy stage. Pipeline Role: Assumed by CodePipeline to invoke the different stages on your behalf.  If you are curious, you can explore the IAM policies for each of these roles in the CloudFormation template.\n"
},
{
	"uri": "/manualdeploy/deploy.html",
	"title": "Deploy the app",
	"tags": [],
	"description": "",
	"content": "The sam deploy command deploys your application by launching a CloudFormation stack. This command now comes with a guided interactive mode, which you can enable by specifying the \u0026ndash;guided parameter. It walks you through the parameters required for deployment, provides default options, and saves these options in a configuration file in your project folder.\nRun the following command in the same directory level where the packaged.yaml is located:\nsam deploy --guided It will ask for certain input parameters, like so:\nConfirm deployment At some point, SAM will ask for deployment confirmation. This is possible because it first creates a CloudFormation ChangeSet, and then it asks for confirmation to execute it. This is kind of like a dry run deployment and is a best practice when doing deployments via CloudFormation. Type y to confirm.\nDeployment completed This command might take a few minutes to finish because it is creating the resources (Lambda function, API Gateway and IAM roles) on the AWS account. When it completes successfully, you should see an output similar to the following:\nWhat just happened? The guided deployment does few things for you. Let\u0026rsquo;s take a quick look at what happened under the hood during the guided deployment to understand this process better.\n1) Your codebase gets packaged in a zip file.\n2) SAM creates an S3 bucket in your account, if it doesn\u0026rsquo;t already exist.\n3) Zip file is uploaded to the S3 bucket.\n4) SAM creates the packaged template that references the location of the zip file on S3.\n5) This template is also uploaded to the S3 bucket.\n6) SAM starts the deployment via CloudFormation ChangeSets.\nThe first time you do a guided deployment, a new file samconfig.toml is created in the root of your project with your specified deployment parameters, this is so that the next time you execute sam deploy, it uses the same parameters without having you to enter them again.\nIf you want to learn more about guided deployments and the samconfig.toml file, here is a good Blog Post: https://aws.amazon.com/blogs/compute/a-simpler-deployment-experience-with-aws-sam-cli.\n"
},
{
	"uri": "/manualdeploy.html",
	"title": "Manual Deploy to AWS",
	"tags": [],
	"description": "",
	"content": "Manual deploy to AWS Before we start building a fully automated continous delivery pipeline, in this chapter you will learn how to build, package and deploy a Serverless application by using the AWS SAM CLI.\nEven though this workshop is about automating deployments, this chapter is very important to learn the foundation of how to package and deploy a Serverless application. You need to learn the basic commands that you will be automating with a pipeline in the next chapter.\n"
},
{
	"uri": "/local/unittests.html",
	"title": "Run the unit tests",
	"tags": [],
	"description": "",
	"content": "As you typically would, with any software project, running the unit tests locally is no different for Serverless applications. Developers run them before pushing changes to a code repository. So, go ahead and run the unit tests for your project.\nIn the terminal, run this command from the sam-app/hello-world folder to run the unit tests:\ncd ~/environment/sam-app/hello-world npm run test The tests should fail. This is expected!\nFix the unit test Makes sense right? We changed the response message to hello my friend and the unit test was expecting hello world. This is an easy fix, let\u0026rsquo;s update the unit test.\nOpen the file sam-app/hello-world/tests/unit/test-handler.js and update the expected value for the response to match the new message. The unit test should look like this after the update:\n'use strict'; const app = require('../../app.js'); const chai = require('chai'); const expect = chai.expect; var event, context; describe('Tests index', function () { it('verifies successful response', async () =\u0026gt; { const result = await app.lambdaHandler(event, context) expect(result).to.be.an('object'); expect(result.statusCode).to.equal(200); expect(result.body).to.be.an('string'); let response = JSON.parse(result.body); expect(response).to.be.an('object'); expect(response.message).to.be.equal(\u0026quot;hello my friend\u0026quot;); // \u0026lt;- FIX }); }); Run the tests again Run the same command again.\nnpm run test Now the tests should pass: This project uses the Chai Framework for running the unit tests, but you can chose any other framework. SAM doesn\u0026rsquo;t enforce any particular one. You can continue to have the same unit testing workflow that you do in a non-serverless application.\n "
},
{
	"uri": "/canaries/monitor.html",
	"title": "Monitor canary health",
	"tags": [],
	"description": "",
	"content": "Canary deployments are considerably more successful if the code is being monitored during the deployment. You can configure CodeDeploy to automatically roll back the deployment if a specified CloudWatch metric has breached the alarm threshold. Common metrics to monitor are Lambda Invocation errors or Invocation Duration (latency), for example.\nDefine a CloudWatch Alarm Add the following alarm definition to the template.yaml file in the Resources section after the HelloWorldFunction definition.\nCanaryErrorsAlarm: Type: AWS::CloudWatch::Alarm Properties: AlarmDescription: Lambda function canary errors ComparisonOperator: GreaterThanThreshold EvaluationPeriods: 2 MetricName: Errors Namespace: AWS/Lambda Period: 60 Statistic: Sum Threshold: 0 Dimensions: - Name: Resource Value: !Sub \u0026quot;${HelloWorldFunction}:live\u0026quot; - Name: FunctionName Value: !Ref HelloWorldFunction - Name: ExecutedVersion Value: !GetAtt HelloWorldFunction.Version.Version And then add the following lines to the DeploymentPreference section of the HelloWorldFunction definition.\nAlarms: - !Ref CanaryErrorsAlarm Your template.yaml should look like this:\nAWSTemplateFormatVersion: \u0026#39;2010-09-09\u0026#39; Transform: AWS::Serverless-2016-10-31 Description: \u0026gt; sam-app Sample SAM Template for sam-app Globals: Function: Timeout: 3 Resources: HelloWorldFunction: Type: AWS::Serverless::Function Properties: CodeUri: hello-world/ Handler: app.lambdaHandler Runtime: nodejs10.x AutoPublishAlias: live DeploymentPreference: Type: Canary10Percent5Minutes Alarms: - !Ref CanaryErrorsAlarm Events: HelloWorld: Type: Api Properties: Path: /hello Method: get CanaryErrorsAlarm: Type: AWS::CloudWatch::Alarm Properties: AlarmDescription: Lambda function canary errors ComparisonOperator: GreaterThanThreshold EvaluationPeriods: 2 MetricName: Errors Namespace: AWS/Lambda Period: 60 Statistic: Sum Threshold: 0 Dimensions: - Name: Resource Value: !Sub \u0026#34;${HelloWorldFunction}:live\u0026#34; - Name: FunctionName Value: !Ref HelloWorldFunction - Name: ExecutedVersion Value: !GetAtt HelloWorldFunction.Version.Version Outputs: # ServerlessRestApi is an implicit API created out of Events key under Serverless::Function # Find out more about other implicit resources you can reference within SAM # https://github.com/awslabs/serverless-application-model/blob/master/docs/internals/generated_resources.rst#api HelloWorldApi: Description: \u0026#34;API Gateway endpoint URL for Prod stage for Hello World function\u0026#34; Value: !Sub \u0026#34;https://${ServerlessRestApi}.execute-api.${AWS::Region}.amazonaws.com/Prod/hello/\u0026#34; HelloWorldFunction: Description: \u0026#34;Hello World Lambda Function ARN\u0026#34; Value: !GetAtt HelloWorldFunction.Arn HelloWorldFunctionIamRole: Description: \u0026#34;Implicit IAM Role created for Hello World function\u0026#34; Value: !GetAtt HelloWorldFunctionRole.Arn Validate the SAM template Run the following command on your terminal:\ncd ~/environment/sam-app sam validate If the template is correct, you will see template.yaml is a valid SAM Template. If you see an error, then you likely have an indentation issue on the YAML file. Double check and make sure it matches the screenshot shown above.\nPush the changes In the terminal, run the following commands from the root directory of your sam-app project.\ngit add . git commit -m \u0026quot;Added CloudWatch alarm to monitor the canary\u0026quot; git push "
},
{
	"uri": "/canaries/codedeploy.html",
	"title": "Verify in CodeDeploy",
	"tags": [],
	"description": "",
	"content": "Wait for your pipeline to get to the deployment stage (ExecuteChangeSet) and when you see it In Progress. Navigate to the CodeDeploy console to watch the deployment progress.\nNavigate to the AWS CodeDeploy console and after a couple of minutes, you should see a new deployment in progress. Click on the Deployment to see the details.\nThe deployment status shows that 10% of the traffic has been shifted to the new version (aka The Canary). CodeDeploy will hold the remaining percentage until the specified time interval has ellapsed, in this case we specified the interval to be 5 minutes.\nShortly after the 5 minutes, the remaining traffic should be shifted to the new version:\n"
},
{
	"uri": "/buildpipe/verify.html",
	"title": "Verify creation",
	"tags": [],
	"description": "",
	"content": "Navigate to the AWS CodePipeline Console and click on your pipeline name to check its details.\nThe Build step should have failed. This is expected because we haven\u0026rsquo;t specified what commands to run on the build yet.\n"
},
{
	"uri": "/buildpipe.html",
	"title": "Build the pipeline",
	"tags": [],
	"description": "",
	"content": "Build the pipeline In this chapter you are going to automate the build, package and deploy commands by creating a continous delivery pipeline that, a high level, looks like the diagram below.\nThe services used in this chapter are AWS CodeCommit, AWS CodeBuild, AWS CodePipeline, AWS CloudFormation and the AWS Serverless Application Repository.\n"
},
{
	"uri": "/manualdeploy/verify.html",
	"title": "Verify deployment",
	"tags": [],
	"description": "",
	"content": "Now that your Serverless application is deployed to an AWS account, let\u0026rsquo;s check if it is running as expected.\nOpen the CloudFormation console Navigate to the AWS CloudFormation console, make sure you are in the same region where you have been working on so far. You should see the new stack sam-app in the CREATE_COMPLETE status.\nTest the app Click on the sam-app stack and then go to the Outputs tab. In this tab, you will see the API Gateway URL, the Lambda function ARN and the IAM Role ARN for the function. To test our application, copy the API Gateway endpoint URL and pase it in a new browser window.\nWhen you navigate to this URL in the browser, API Gateway is invoking the Hello World Lambda function. If everything works, you will see Lambda response:\nCongratulations! You have successfully deployed a Serverless application! Let\u0026rsquo;s automate deployments now!\n"
},
{
	"uri": "/canaries/rollbacks.html",
	"title": "Rollbacks",
	"tags": [],
	"description": "",
	"content": "Monitoring the health of your canary allows CodeDeploy to make a decision to whether a rollback is needed or not. If any of the CloudWatch Alarms specified gets to ALARM status, CodeDeploy rollsback the deployment automatically.\nIntroduce an error on purpose Lets break the Lambda function on purpose so that the CanaryErrorsAlarm gets triggered during deployment. Update the lambda code in sam-app/hello-world/app.js to throw an error on every invocation, like this:\nlet response; exports.lambdaHandler = async (event, context) =\u0026gt; { throw new Error(\u0026quot;This will cause a deployment rollback\u0026quot;); // try { // response = { // 'statusCode': 200, // 'body': JSON.stringify({ // message: 'hello my friend with canaries', // }) // } // } catch (err) { // console.log(err); // return err; // } // return response }; Make sure to update the unit test, otherwise the build will fail. Comment out every line in the sam-app/hello-world/tests/unit/test-handler.js file:\n// 'use strict'; // const app = require('../../app.js'); // const chai = require('chai'); // const expect = chai.expect; // var event, context; // describe('Tests index', function () { // it('verifies successful response', async () =\u0026gt; { // const result = await app.lambdaHandler(event, context) // expect(result).to.be.an('object'); // expect(result.statusCode).to.equal(200); // expect(result.body).to.be.an('string'); // let response = JSON.parse(result.body); // expect(response).to.be.an('object'); // expect(response.message).to.be.equal(\u0026quot;hello my friend with canaries\u0026quot;); // }); // }); Push the changes In the terminal, run the following commands from the root directory of your sam-app project.\ngit add . git commit -m \u0026quot;Breaking the lambda function on purpose\u0026quot; git push "
},
{
	"uri": "/buildpipe/buildspec.html",
	"title": "Write the buildspec file",
	"tags": [],
	"description": "",
	"content": "A buildspec file is a series of commands in YAML format that CodeBuild runs to build your application.\nCreate a new file named buildspec.yml in the root of the sam-app directory and copy the following contents into it. It is very important that the file is placed in the root, otherwise CodeBuild will not be able to find it.\nIn Cloud9, right click on the sam-app directory to create a new file. Name it buildspec.yml.\nThen, paste the following content into the file:\n# ~/environment/sam-app/buildspec.yml version: 0.2 phases: install: runtime-versions: nodejs: 12 commands: # Install packages or any pre-reqs in this phase. # Upgrading SAM CLI to latest version - pip3 install --upgrade aws-sam-cli - sam --version # Installing project dependencies - cd hello-world - npm install pre_build: commands: # Run tests, lint scripts or any other pre-build checks. - npm run test build: commands: # Use Build phase to build your artifacts (compile, etc.) - cd .. - sam build post_build: commands: # Use Post-Build for notifications, git tags, upload artifacts to S3 - sam package --s3-bucket $PACKAGE_BUCKET --output-template-file packaged.yaml artifacts: discard-paths: yes files: # List of local artifacts that will be passed down the pipeline - packaged.yaml Save the file. It should look like this (take a moment to understand it):\nPush code changes Commit your changes and push them to the repository.\ngit add . git commit -m \u0026quot;Added buildspec.yml\u0026quot; git push "
},
{
	"uri": "/buildpipe/done.html",
	"title": "Verify pipeline running",
	"tags": [],
	"description": "",
	"content": "Once you push the buildspec.yaml file into the code repository, the pipeline should trigger automatically. This time, the build step should succeed along with the deployment steps.\nThis pipeline performs deployments using CloudFormation ChangeSets. If you are not familiar with them, you can learn about them here: https://docs.aws.amazon.com/AWSCloudFormation/latest/UserGuide/using-cfn-updating-stacks-changesets.html.\n Congratulations! You have created a CI/CD pipeline. "
},
{
	"uri": "/canaries.html",
	"title": "Canary Deployments",
	"tags": [],
	"description": "",
	"content": "Canary Deployments A Canary Deployment is a technique that reduces the risk of deploying a new version of an application by slowly rolling out the changes to a small subset of users before rolling it out to the entire customer base.\nIn this chapter you will learn how to implement gradual deployments with AWS SAM, AWS CloudFormation and AWS CodeDeploy with just a few lines of configuration.\n"
},
{
	"uri": "/canaries/finished.html",
	"title": "The end",
	"tags": [],
	"description": "",
	"content": "Thank you for doing this workshop! We hope you learned something. Stay tuned on this website as we are working on new modules! If you have a suggestion or feedback to improve this workshop, please let us know in our GitHub repository. "
},
{
	"uri": "/buildpipe/launch.html",
	"title": "",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/categories.html",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "/tags.html",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]